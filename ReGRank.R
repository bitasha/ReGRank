#rmat: rating matrix m*n
#usersequence: a list of array such that  userSeq[[i]] contains items that are rated by i-th user 
#       (is generated by makeUserseq function)

#rl: length of recommendation list (NDCG@rl)
#trl : length of traiing profile of each user (i.e. UPL)
#nl:  length of neighborhood size (typically set to 100)
#direc: the direction of check point recorder 
#trdirec: the direction for training file if available 
#first run : a logic variable to indicate if the evaluation should be initialized or it should be continued based on the check point file
#dampingFactor: the damping factor for graph-based similarity measure
#trainflag:a logical variable to indicate training set  should be generated randomly(0) or load from file(1)
#smet: type of semantic analysis: smet=1: user-based, smet=2: P-ReGRank, smet=3: R-ReGRank

rankEvaluation_Yu_ReGRank<-function(rmat,userSeq,rl=c(1,3,5,10),trl,direc,firstRun,trainflag=0,damping=0.85,trdirec,smet){
  
  userLength= calUserLength(userSeq);
  NDCG=matrix(0,length(trl),length(rl));  
  count=matrix(0,length(trl),length(rl));
  param=c(1,1,0,0)
  tt=0;
  tt2=0;
  if(firstRun==0){
    direcFile=read.csv(direc)
    direcFile=direcFile[,-1]
    param=as.numeric(direcFile[1,]);          st=2;     end=st+length(trl)-1;
    NDCG=data.matrix(direcFile[st:(end),]);     st=end+1; end=st+length(trl)-1;
    count=data.matrix(direcFile[st:end,]);  
    userLength= calUserLength(userSeq); tt=0;
    tt2=param[4];
  }
  
  for(w in param[1]:length(trl)){            
    j=trl[w]
    t=Yu_prepareData(rmat,j+max(rl),userSeq);
    userSeq=t@us;
    rmat=t@rmat2;

    for(i in param[2]:1){
      #trList and testListindices of user in train and tes
      testSet= 1:nrow(rmat);
      trList=c(1:nrow(rmat));
      tr=trList_random(userSeq,j,testSet); 
      if(trainflag==1){
        x=read.csv(trdirec);x=x[,-1]
        tr=lapply(seq_len(nrow(x)),function(i) as.numeric(x[i,]))
      }else{
        writeTrain(tr,trList,trdirec); 
      }
   
      ###**********************************
        trMat=makeTrainMat(tr,rmat);
        tt<-tt+system.time(l<-make3LGraph_2(rmat ,userSeq,testSet,tr));
        g<-graph.edgelist(l[,1:2],directed = F);
        
        if(smet==1){
          trans=transformMatrix2_normallAll(g,nrow(rmat),ncol(rmat))$trans;
        }
        if(smet==2){
          trans=transformMatrix4_normallAll(g,nrow(rmat),ncol(rmat))$trans;
        }
        if(smet==3){
          trans=transformMatrix6_normallAll(g,nrow(rmat),ncol(rmat))$trans;
        }
        trans=as(trans, "sparseMatrix") 
        nalist=which(is.na(trans));
        if(length(nalist)>0)
          trans[nalist]=0
      
      
      for(uid in (param[3]+1):length(testSet)){
        if((uid%%50)==0)
          gc(T);
        tp={};
        for(h in 1:length(tr[[testSet[[uid]]]])){
          tp=c(tp,which(userSeq[[testSet[uid]]]==tr[[uid]][h]))
        }
        ts=userSeq[[testSet[uid]]][-tp];
        
        sh=1;
        
        #tt=tt+system.time(f<-makeGraphMat3L(g,uid,tr,ts ,rmat =rmat));
        tt2=tt2+system.time(f<-pathrank(trans,id = uid,nrow(rmat),ncol(rmat)));
        
        for(d in 1:length(rl)){
          topK=rl[d];
          r=order(f,decreasing=T);
          r=intersect(r,ts);
          recomList=r[1:topK];
          count[w,d]=count[w,d]+1;
          NDCG[w,d]=NDCG[w,d]+calNDCG(f[ts],rmat[testSet[uid],ts],topK);
        }
          if(uid%%50==0){        
            print(c(uid,NDCG/count))
            checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
            write.csv(checkRes,direc);
          }
      }
      
      checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
      
      write.csv(checkRes,direc);
      
    }
    print("NDCG")
    print(NDCG/count)
    print(c("tt",tt));
    # prec=prec/(count);    
    # reca=reca/(count);
    # NDCG=NDCG/(count);
    
  }    
  
  ev=setClass("ev",slots=c("NDCGALL","count","t1"));
  evt=new("ev",NDCGALL=NDCG/count,count=count,t1=tt2);                        
  return(evt)
}
library(igraph)
pathrank<-function(trans,id,nr,nc){
  trans=t(trans)
  rank=rep(1,nrow(trans))
  rank=rank/sum(rank)
  rank=matrix(rank,length(rank),1);
  p=matrix(0,length(rank),1);
  p[id]=1
  for(i in 1:20){
    rank=0.85*trans%*%matrix(rank,length(rank),1)+0.15*p;
    #rank=(0.85*(crossprod(t(trans),rank)));
    #rank[id,1]=rank[id,1]+0.15;
    #rank=rank/sum(rank);
    #rank=rank+(1-sum(rank))/length(rank);
    rank[id,1]=rank[id,1]+(1-sum(rank));
  }
  l=rank[(length(rank)-2*nc+1):length(rank)]
  v=l[seq(from=1,to=length(l),by=2)]
  v2=l[seq(from=2,to=length(l),by=2)]
  v=v-v2;
  #v=v/(v+v2);
  return(v);
}

make3LGraph_2<-function(rmat,us,testSet,tr,perc=1){
  print("constructing graph")
  #l=matrix(0,ncol(rmat)^2+nrow(rmat),ncol(rmat)^2+nrow(rmat));
  l=rep(0,2);
  count=1
  countp=0;
  t2=matrix(0,5000,2);
  t3=rep(0,2);
  
  for(i in 1:nrow(rmat)){
    uid=i;
    print(uid)
    if(any(testSet==i)){
      r=(tr[[which(testSet==i)]]);
    }
    else{
      r=which(!is.na(rmat[uid,]));
    }    
    s=splitRating(rmat,uid,r);
    m=0;
    if(length(s)>1){
      for( uu in 1:(length(s)-1))
        for(hh in (uu+1):(length(s)))
          m=m+length(s[[hh]])*length(s[[uu]]);
        t2=matrix(0,m,2)
        if((countp%%10000)==0)
          print(i)
        for(j in 1:(length(s)-1)){
          for(k in ((j+1):length(s))){
            if(length(s[[j]])>0&&length(s[[k]])>0){
              t=tList(i,s[[j]],s[[k]],rmat)
              countp=countp+nrow(t);
              tl=count+nrow(t)-1;
              t2[count:tl,]=t;
              count=count+nrow(t);
              
            }
          }
        }    
        
        t3=rbind(t3,t2);   
    }
    count=1;
  }
  if(countp>0){
    print(c(dim(l),dim(t3),dim(t3[-1,])))
    l=rbind(l,t3[-1,]);
  }
  print("L3")
  l=l[-1,]
  st=nrow(rmat)+1;
  end=nrow(rmat)+ncol(rmat)*ncol(rmat);
  u=matrix(0,2*ncol(rmat)*ncol(rmat),2)
  rc=1;
  per=sample(1:nrow(l),floor(perc*nrow(l)))
  l=l[per,]  
  for(k in st:end){
    q=rep(0,2);
    t=ceiling((k-st+1)/ncol(rmat)); #node barande
    t2=(k-st+1)%% ncol(rmat);#node bazande    
    if(t2==0){
      t2=ncol(rmat);
    }
    q=rbind(q,c(k,end+2*t-1));
    q=rbind(q,c(k,end+2*t2));    
    u[rc:(rc+1),]=q[-1,];
    rc=rc+2
  }
  print("graph is constructed")
  l=rbind(l,u)
  return(l);
}
ppr<-function(g, personalized=rep(1/vcount(g),vcount(g)),damping=0.85){
  personalized=personalized/sum(personalized)
  r=(get.adjacency(g));
  e=(drop0(r))
  p=colSums(e);
  e=crossprod(r,solve(Diagonal(x=p)))
  m=personalized
  m=m/sum(m)
  m=matrix(m,length(m),1)
  er=rep(0,100)
  l=which(personalized!=0)
  for(i in 1:20){  
    m2=damping*(e%*%m)+(1-damping)*personalized;
    er[i]=sum((m-m2)^2);
    m=m2
    if(er[i]<0.000001)
      break;
  }
  return(m)
}
#U-REGRank
transformMatrix2_normallAll<-function(g,nr,nc){
  # p=array(list(),length(w)),
  UInd=1:nr;
  PInd=(nr+1):(vcount(g)-2*nc);
  RInd=(vcount(g)-2*nc+1):vcount(g)
  r=get.adjacency(g)
  r=drop0(r);
  rup_1=r[UInd,PInd]
  rpr_1=r[PInd,RInd]
  rAll=t(crossprod((r),solve(Diagonal(x=colSums(r)))))
  rpu=rAll[PInd,UInd]
  rup=rAll[UInd,PInd]
  rpr=rAll[PInd,RInd]
  rrp=rAll[RInd,PInd]
  
  
  #rpu=t(crossprod(t(rup_1),solve(Diagonal(x=colSums(r[PInd,])))))
  #rup=t(crossprod((rup_1),solve(Diagonal(x=colSums(t(rup_1))))))
  #rpr=t(crossprod((rpr_1),solve(Diagonal(x=colSums((r[PInd,]))))))
  #rrp=t(crossprod(t(rpr_1),solve(Diagonal(x=colSums((rpr_1))))))
  
  print("h")
  mp1=rup%*%rpu;
  mp2=rrp%*%rpu;
  mp3=rup%*%rpr;
  print("m")
  smp1=summary(mp1)
  tm1=sparseMatrix(i=smp1[,1],j=smp1[,2],x=smp1[,3],dims=c(vcount(g),vcount(g)))
  smp2=summary(mp2)
  tm2=sparseMatrix(i=RInd[smp2[,1]],j=smp2[,2],x=smp2[,3],dims=c(vcount(g),vcount(g)))
  smp3=summary(mp3)
  tm3=sparseMatrix(i=smp3[,1],j=RInd[smp3[,2]],x=smp3[,3],dims=c(vcount(g),vcount(g)))
  #trans=0.5*tm1+tm2+0.5*tm3
  trans=tm1+tm2+tm3;
  trans=trans[-((nr+1):(ncol(trans)-2*nc)),-((nr+1):(ncol(trans)-2*nc))]
  ss=rowSums(trans)
  print("XXXXX")
  # for(i in 1:nrow(trans))
  #   trans[i,]=trans[i,]/ss[i]
  gc(T)
  v1 <- rowSums(trans)
  trans=as(trans,"matrix")
  trans=prop.table(trans,1)
  print("yyy")
  # for(k in 1:nrow(trans)){
  #   print(k)
  #   trans[k,] <- trans[k,]/v1[k]
  # }
  #trans=sweep(trans,1,rowSums(trans),FUN ="/")
  
  #trans=t(crossprod(t(trans),solve(Diagonal(x=colSums(trans)))))
  x="*"
  return(environment())
}


#P_ReGRank
transformMatrix4_normallAll<-function(g,nr,nc){
  # p=array(list(),length(w)),
  UInd=1:nr;
  PInd=(nr+1):(vcount(g)-2*nc);
  RInd=(vcount(g)-2*nc+1):vcount(g)
  r=get.adjacency(g)
  r=drop0(r);
  rup_1=r[UInd,PInd]
  rpr_1=r[PInd,RInd]
  rAll=t(crossprod((r),solve(Diagonal(x=colSums(r)))))
  rpu=rAll[PInd,UInd]
  rup=rAll[UInd,PInd]
  rpr=rAll[PInd,RInd]
  rrp=rAll[RInd,PInd]
  
  
  #rpu=t(crossprod(t(rup_1),solve(Diagonal(x=colSums(r[PInd,])))))
  #rup=t(crossprod((rup_1),solve(Diagonal(x=colSums(t(rup_1))))))
  #rpr=t(crossprod((rpr_1),solve(Diagonal(x=colSums((r[PInd,]))))))
  #rrp=t(crossprod(t(rpr_1),solve(Diagonal(x=colSums((rpr_1))))))
  
  
  mp1=rup%*%rpu;
  mp2=rrp%*%rpu;
  mp3=rup%*%rpr;
  smp1=summary(mp1)
  tm1=sparseMatrix(i=smp1[,1],j=smp1[,2],x=smp1[,3],dims=c(vcount(g),vcount(g)))
  smp2=summary(mp2)
  tm2=sparseMatrix(i=RInd[smp2[,1]],j=smp2[,2],x=smp2[,3],dims=c(vcount(g),vcount(g)))
  smp3=summary(mp3)
  tm3=sparseMatrix(i=smp3[,1],j=RInd[smp3[,2]],x=smp3[,3],dims=c(vcount(g),vcount(g)))
  #trans=0.5*tm1+tm2+0.5*tm3
  trans=tm1+tm3;
  trans=trans[-((nr+1):(ncol(trans)-2*nc)),-((nr+1):(ncol(trans)-2*nc))]
  ss=rowSums(trans)
  # for(i in 1:nrow(trans))
  #   trans[i,]=trans[i,]/ss[i]
  #trans=sweep(trans,1,rowSums(trans),FUN ="/")
  #v1 <- rowSums(trans)
  #trans <- trans/(v1)
  trans=as(trans,"matrix")
  trans=prop.table(trans,1)
  #trans=t(crossprod(t(trans),solve(Diagonal(x=colSums(trans)))))
  x="*"
  return(environment())
}


#R-REGRank
transformMatrix6_normallAll<-function(g,nr,nc){
  # p=array(list(),length(w)),
  UInd=1:nr;
  PInd=(nr+1):(vcount(g)-2*nc);
  RInd=(vcount(g)-2*nc+1):vcount(g)
  r=get.adjacency(g)
  r=drop0(r);
  rup_1=r[UInd,PInd]
  rpr_1=r[PInd,RInd]
  rAll=t(crossprod((r),solve(Diagonal(x=colSums(r)))))
  rpu=rAll[PInd,UInd]
  rup=rAll[UInd,PInd]
  rpr=rAll[PInd,RInd]
  rrp=rAll[RInd,PInd]
  
  
  #rpu=t(crossprod(t(rup_1),solve(Diagonal(x=colSums(r[PInd,])))))
  #rup=t(crossprod((rup_1),solve(Diagonal(x=colSums(t(rup_1))))))
  #rpr=t(crossprod((rpr_1),solve(Diagonal(x=colSums((r[PInd,]))))))
  #rrp=t(crossprod(t(rpr_1),solve(Diagonal(x=colSums((rpr_1))))))
  
  
  mp1=rup%*%rpu;
  mp2=rrp%*%rpu;
  mp3=rup%*%rpr;
  smp1=summary(mp1)
  tm1=sparseMatrix(i=smp1[,1],j=smp1[,2],x=smp1[,3],dims=c(vcount(g),vcount(g)))
  smp2=summary(mp2)
  tm2=sparseMatrix(i=RInd[smp2[,1]],j=smp2[,2],x=smp2[,3],dims=c(vcount(g),vcount(g)))
  smp3=summary(mp3)
  tm3=sparseMatrix(i=smp3[,1],j=RInd[smp3[,2]],x=smp3[,3],dims=c(vcount(g),vcount(g)))
  #trans=0.5*tm1+tm2+0.5*tm3
  trans=tm2+tm3;
  trans=trans[-((nr+1):(ncol(trans)-2*nc)),-((nr+1):(ncol(trans)-2*nc))]
  ss=rowSums(trans)
  # for(i in 1:nrow(trans))
  #   trans[i,]=trans[i,]/ss[i]
  # trans=sweep(trans,1,rowSums(trans),FUN ="/")
  #v1 <- rowSums(trans)
  #trans <- trans/(v1)
  trans=as(trans,"matrix")
  trans=prop.table(trans,1)
  #trans=t(crossprod(t(trans),solve(Diagonal(x=colSums(trans)))))
  x="*"
  return(environment())
}
